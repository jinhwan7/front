{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar isPlainObject = require('is-plain-object');\nvar React = require('react');\nvar prettyPrintObject = require('@base2/pretty-print-object');\nvar reactIs = require('react-is');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar spacer = function (times, tabStop) {\n  if (times === 0) {\n    return '';\n  }\n  return new Array(times * tabStop).fill(' ').join('');\n};\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction safeSortObject(value, seen) {\n  // return non-object value as is\n  if (value === null || _typeof(value) !== 'object') {\n    return value;\n  } // return date, regexp and react element values as is\n\n  if (value instanceof Date || value instanceof RegExp || /*#__PURE__*/React__namespace.isValidElement(value)) {\n    return value;\n  }\n  seen.add(value); // make a copy of array with each item passed through the sorting algorithm\n\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return safeSortObject(v, seen);\n    });\n  } // make a copy of object with key sorted\n\n  return Object.keys(value).sort().reduce(function (result, key) {\n    if (key === '_owner') {\n      return result;\n    }\n    if (key === 'current' || seen.has(value[key])) {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = '[Circular]';\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = safeSortObject(value[key], seen);\n    }\n    return result;\n  }, {});\n}\nfunction sortObject(value) {\n  return safeSortObject(value, new WeakSet());\n}\n\n/* eslint-disable no-use-before-define */\nvar createStringTreeNode = function createStringTreeNode(value) {\n  return {\n    type: 'string',\n    value: value\n  };\n};\nvar createNumberTreeNode = function createNumberTreeNode(value) {\n  return {\n    type: 'number',\n    value: value\n  };\n};\nvar createReactElementTreeNode = function createReactElementTreeNode(displayName, props, defaultProps, childrens) {\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: defaultProps,\n    childrens: childrens\n  };\n};\nvar createReactFragmentTreeNode = function createReactFragmentTreeNode(key, childrens) {\n  return {\n    type: 'ReactFragment',\n    key: key,\n    childrens: childrens\n  };\n};\nvar supportFragment = Boolean(React.Fragment);\nvar getFunctionTypeName = function getFunctionTypeName(functionType) {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\nvar getWrappedComponentDisplayName = function getWrappedComponentDisplayName(Component) {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === reactIs.Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === reactIs.ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n}; // heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\n\nvar getReactElementDisplayName = function getReactElementDisplayName(element) {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case reactIs.isForwardRef(element):\n    case reactIs.isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case reactIs.isContextConsumer(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Consumer\");\n    case reactIs.isContextProvider(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Provider\");\n    case reactIs.isLazy(element):\n      return 'Lazy';\n    case reactIs.isProfiler(element):\n      return 'Profiler';\n    case reactIs.isStrictMode(element):\n      return 'StrictMode';\n    case reactIs.isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\nvar noChildren = function noChildren(propsValue, propName) {\n  return propName !== 'children';\n};\nvar onlyMeaningfulChildren = function onlyMeaningfulChildren(children) {\n  return children !== true && children !== false && children !== null && children !== '';\n};\nvar filterProps = function filterProps(originalProps, cb) {\n  var filteredProps = {};\n  Object.keys(originalProps).filter(function (key) {\n    return cb(originalProps[key], key);\n  }).forEach(function (key) {\n    return filteredProps[key] = originalProps[key];\n  });\n  return filteredProps;\n};\nvar parseReactElement = function parseReactElement(element, options) {\n  var _options$displayName = options.displayName,\n    displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (! /*#__PURE__*/React__default[\"default\"].isValidElement(element)) {\n    throw new Error(\"react-element-to-jsx-string: Expected a React.Element, got `\".concat(_typeof(element), \"`\"));\n  }\n  var displayName = displayNameFn(element);\n  var props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n  var key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  var childrens = React__default[\"default\"].Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function (child) {\n    return parseReactElement(child, options);\n  });\n  if (supportFragment && element.type === React.Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n  return createReactElementTreeNode(displayName, props, defaultProps, childrens);\n};\nfunction noRefCheck() {}\nvar inlineFunction = function inlineFunction(fn) {\n  return fn.toString().split('\\n').map(function (line) {\n    return line.trim();\n  }).join('');\n};\nvar preserveFunctionLineBreak = function preserveFunctionLineBreak(fn) {\n  return fn.toString();\n};\nvar defaultFunctionValue = inlineFunction;\nvar formatFunction = function (fn, options) {\n  var _options$functionValu = options.functionValue,\n    functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu,\n    showFunctions = options.showFunctions;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n  return functionValue(fn);\n};\nvar formatComplexDataStructure = function (value, inline, lvl, options) {\n  var normalizedValue = sortObject(value);\n  var stringifiedValue = prettyPrintObject.prettyPrint(normalizedValue, {\n    transform: function transform(currentObj, prop, originalResult) {\n      var currentValue = currentObj[prop];\n      if (currentValue && /*#__PURE__*/React.isValidElement(currentValue)) {\n        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);\n      }\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n      return originalResult;\n    }\n  });\n  if (inline) {\n    return stringifiedValue.replace(/\\s+/g, ' ').replace(/{ /g, '{').replace(/ }/g, '}').replace(/\\[ /g, '[').replace(/ ]/g, ']');\n  } // Replace tabs with spaces, and add necessary indentation in front of each new line\n\n  return stringifiedValue.replace(/\\t/g, spacer(1, options.tabStop)).replace(/\\n([^$])/g, \"\\n\".concat(spacer(lvl + 1, options.tabStop), \"$1\"));\n};\nvar escape$1 = function escape(s) {\n  return s.replace(/\"/g, '&quot;');\n};\nvar formatPropValue = function formatPropValue(propValue, inline, lvl, options) {\n  if (typeof propValue === 'number') {\n    return \"{\".concat(String(propValue), \"}\");\n  }\n  if (typeof propValue === 'string') {\n    return \"\\\"\".concat(escape$1(propValue), \"\\\"\");\n  } // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n\n  if (_typeof(propValue) === 'symbol') {\n    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\\((.*)\\)/, '$1');\n    if (!symbolDescription) {\n      return \"{Symbol()}\";\n    }\n    return \"{Symbol('\".concat(symbolDescription, \"')}\");\n  }\n  if (typeof propValue === 'function') {\n    return \"{\".concat(formatFunction(propValue, options), \"}\");\n  }\n  if ( /*#__PURE__*/React.isValidElement(propValue)) {\n    return \"{\".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), \"}\");\n  }\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return \"{new Date(NaN)}\";\n    }\n    return \"{new Date(\\\"\".concat(propValue.toISOString(), \"\\\")}\");\n  }\n  if (isPlainObject.isPlainObject(propValue) || Array.isArray(propValue)) {\n    return \"{\".concat(formatComplexDataStructure(propValue, inline, lvl, options), \"}\");\n  }\n  return \"{\".concat(String(propValue), \"}\");\n};\nvar formatProp = function (name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\"The prop \\\"\".concat(name, \"\\\" has no value and no default: could not be formatted\"));\n  }\n  var usedValue = hasValue ? value : defaultValue;\n  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax,\n    tabStop = options.tabStop;\n  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n  var attributeFormattedInline = ' ';\n  var attributeFormattedMultiline = \"\\n\".concat(spacer(lvl + 1, tabStop));\n  var isMultilineAttribute = formattedPropValue.includes('\\n');\n  if (useBooleanShorthandSyntax && formattedPropValue === '{false}' && !hasDefaultValue) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += \"\".concat(name);\n    attributeFormattedMultiline += \"\".concat(name);\n  } else {\n    attributeFormattedInline += \"\".concat(name, \"=\").concat(formattedPropValue);\n    attributeFormattedMultiline += \"\".concat(name, \"=\").concat(formattedPropValue);\n  }\n  return {\n    attributeFormattedInline: attributeFormattedInline,\n    attributeFormattedMultiline: attributeFormattedMultiline,\n    isMultilineAttribute: isMultilineAttribute\n  };\n};\nvar mergeSiblingPlainStringChildrenReducer = function (previousNodes, currentNode) {\n  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);\n  var previousNode = previousNodes[previousNodes.length - 1];\n  if (previousNode && (currentNode.type === 'string' || currentNode.type === 'number') && (previousNode.type === 'string' || previousNode.type === 'number')) {\n    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n    nodes.push(currentNode);\n  }\n  return nodes;\n};\nvar isKeyOrRefProps = function isKeyOrRefProps(propName) {\n  return ['key', 'ref'].includes(propName);\n};\nvar sortPropsByNames = function (shouldSortUserProps) {\n  return function (props) {\n    var haveKeyProp = props.includes('key');\n    var haveRefProp = props.includes('ref');\n    var userPropsOnly = props.filter(function (oneProp) {\n      return !isKeyOrRefProps(oneProp);\n    });\n    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) // We use basic lexical order\n    : _toConsumableArray(userPropsOnly);\n    if (haveRefProp) {\n      sortedProps.unshift('ref');\n    }\n    if (haveKeyProp) {\n      sortedProps.unshift('key');\n    }\n    return sortedProps;\n  };\n};\nfunction createPropFilter(props, filter) {\n  if (Array.isArray(filter)) {\n    return function (key) {\n      return filter.indexOf(key) === -1;\n    };\n  } else {\n    return function (key) {\n      return filter(props[key], key);\n    };\n  }\n}\nvar compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation(element, formattedElement, inline, lvl, options) {\n  var tabStop = options.tabStop;\n  if (element.type === 'string') {\n    return formattedElement.split('\\n').map(function (line, offset) {\n      if (offset === 0) {\n        return line;\n      }\n      return \"\".concat(spacer(lvl, tabStop)).concat(line);\n    }).join('\\n');\n  }\n  return formattedElement;\n};\nvar formatOneChildren = function formatOneChildren(inline, lvl, options) {\n  return function (element) {\n    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);\n  };\n};\nvar onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue(defaultProps, props) {\n  return function (propName) {\n    var haveDefaultValue = Object.keys(defaultProps).includes(propName);\n    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];\n  };\n};\nvar isInlineAttributeTooLong = function isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;\n};\nvar shouldRenderMultilineAttr = function shouldRenderMultilineAttr(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {\n  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;\n};\nvar formatReactElementNode = function (node, inline, lvl, options) {\n  var type = node.type,\n    _node$displayName = node.displayName,\n    displayName = _node$displayName === void 0 ? '' : _node$displayName,\n    childrens = node.childrens,\n    _node$props = node.props,\n    props = _node$props === void 0 ? {} : _node$props,\n    _node$defaultProps = node.defaultProps,\n    defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;\n  if (type !== 'ReactElement') {\n    throw new Error(\"The \\\"formatReactElementNode\\\" function could only format node of type \\\"ReactElement\\\". Given:  \".concat(type));\n  }\n  var filterProps = options.filterProps,\n    maxInlineAttributesLineLength = options.maxInlineAttributesLineLength,\n    showDefaultProps = options.showDefaultProps,\n    sortProps = options.sortProps,\n    tabStop = options.tabStop;\n  var out = \"<\".concat(displayName);\n  var outInlineAttr = out;\n  var outMultilineAttr = out;\n  var containsMultilineAttr = false;\n  var visibleAttributeNames = [];\n  var propFilter = createPropFilter(props, filterProps);\n  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function (propName) {\n    return visibleAttributeNames.push(propName);\n  });\n  Object.keys(defaultProps).filter(propFilter).filter(function () {\n    return showDefaultProps;\n  }).filter(function (defaultPropName) {\n    return !visibleAttributeNames.includes(defaultPropName);\n  }).forEach(function (defaultPropName) {\n    return visibleAttributeNames.push(defaultPropName);\n  });\n  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n  attributes.forEach(function (attributeName) {\n    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options),\n      attributeFormattedInline = _formatProp.attributeFormattedInline,\n      attributeFormattedMultiline = _formatProp.attributeFormattedMultiline,\n      isMultilineAttribute = _formatProp.isMultilineAttribute;\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n  outMultilineAttr += \"\\n\".concat(spacer(lvl, tabStop));\n  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n  if (childrens && childrens.length > 0) {\n    var newLvl = lvl + 1;\n    out += '>';\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? \"\\n\".concat(spacer(newLvl, tabStop)) : '');\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += \"</\".concat(displayName, \">\");\n  } else {\n    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {\n      out += ' ';\n    }\n    out += '/>';\n  }\n  return out;\n};\nvar REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nvar REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\nvar toReactElementTreeNode = function toReactElementTreeNode(displayName, key, childrens) {\n  var props = {};\n  if (key) {\n    props = {\n      key: key\n    };\n  }\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: {},\n    childrens: childrens\n  };\n};\nvar isKeyedFragment = function isKeyedFragment(_ref) {\n  var key = _ref.key;\n  return Boolean(key);\n};\nvar hasNoChildren = function hasNoChildren(_ref2) {\n  var childrens = _ref2.childrens;\n  return childrens.length === 0;\n};\nvar formatReactFragmentNode = function (node, inline, lvl, options) {\n  var type = node.type,\n    key = node.key,\n    childrens = node.childrens;\n  if (type !== 'ReactFragment') {\n    throw new Error(\"The \\\"formatReactFragmentNode\\\" function could only format node of type \\\"ReactFragment\\\". Given: \".concat(type));\n  }\n  var useFragmentShortSyntax = options.useFragmentShortSyntax;\n  var displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);\n};\nvar jsxStopChars = ['<', '>', '{', '}'];\nvar shouldBeEscaped = function shouldBeEscaped(s) {\n  return jsxStopChars.some(function (jsxStopChar) {\n    return s.includes(jsxStopChar);\n  });\n};\nvar escape = function escape(s) {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n  return \"{`\".concat(s, \"`}\");\n};\nvar preserveTrailingSpace = function preserveTrailingSpace(s) {\n  var result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n  return result;\n};\nvar formatTreeNode = function (node, inline, lvl, options) {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n  if (node.type === 'string') {\n    return node.value ? \"\".concat(preserveTrailingSpace(escape(String(node.value)))) : '';\n  }\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n  throw new TypeError(\"Unknow format type \\\"\".concat(node.type, \"\\\"\"));\n};\nvar formatTree = function (node, options) {\n  return formatTreeNode(node, false, 0, options);\n};\nvar reactElementToJsxString = function reactElementToJsxString(element) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$filterProps = _ref.filterProps,\n    filterProps = _ref$filterProps === void 0 ? [] : _ref$filterProps,\n    _ref$showDefaultProps = _ref.showDefaultProps,\n    showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps,\n    _ref$showFunctions = _ref.showFunctions,\n    showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions,\n    functionValue = _ref.functionValue,\n    _ref$tabStop = _ref.tabStop,\n    tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop,\n    _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax,\n    useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth,\n    _ref$useFragmentShort = _ref.useFragmentShortSyntax,\n    useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort,\n    _ref$sortProps = _ref.sortProps,\n    sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps,\n    maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength,\n    displayName = _ref.displayName;\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n  var options = {\n    filterProps: filterProps,\n    showDefaultProps: showDefaultProps,\n    showFunctions: showFunctions,\n    functionValue: functionValue,\n    tabStop: tabStop,\n    useBooleanShorthandSyntax: useBooleanShorthandSyntax,\n    useFragmentShortSyntax: useFragmentShortSyntax,\n    sortProps: sortProps,\n    maxInlineAttributesLineLength: maxInlineAttributesLineLength,\n    displayName: displayName\n  };\n  return formatTree(parseReactElement(element, options), options);\n};\nexports[\"default\"] = reactElementToJsxString;\nexports.inlineFunction = inlineFunction;\nexports.preserveFunctionLineBreak = preserveFunctionLineBreak;","map":{"version":3,"mappings":"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","names":["times","tabStop","Array","fill","join","safeSortObject","value","seen","_typeof","Date","RegExp","React","isValidElement","add","isArray","map","v","Object","keys","sort","reduce","result","key","has","sortObject","WeakSet","createStringTreeNode","type","createNumberTreeNode","createReactElementTreeNode","displayName","props","defaultProps","childrens","createReactFragmentTreeNode","supportFragment","Boolean","Fragment","getFunctionTypeName","functionType","name","getWrappedComponentDisplayName","Component","$$typeof","Memo","ForwardRef","render","getReactElementDisplayName","element","isForwardRef","isMemo","isContextConsumer","_context","isContextProvider","isLazy","isProfiler","isStrictMode","isSuspense","noChildren","propsValue","propName","onlyMeaningfulChildren","children","filterProps","originalProps","cb","filteredProps","filter","forEach","parseReactElement","options","displayNameFn","Error","ref","search","Children","toArray","child","noRefCheck","inlineFunction","fn","toString","split","line","trim","preserveFunctionLineBreak","defaultFunctionValue","functionValue","showFunctions","inline","lvl","normalizedValue","stringifiedValue","prettyPrint","transform","currentObj","prop","originalResult","currentValue","formatTreeNode","formatFunction","replace","spacer","escape","s","formatPropValue","propValue","String","symbolDescription","valueOf","isNaN","toISOString","isPlainObject","formatComplexDataStructure","hasValue","hasDefaultValue","defaultValue","usedValue","useBooleanShorthandSyntax","formattedPropValue","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","includes","previousNodes","currentNode","nodes","slice","length","previousNode","push","isKeyOrRefProps","shouldSortUserProps","haveKeyProp","haveRefProp","userPropsOnly","oneProp","sortedProps","_toConsumableArray","unshift","createPropFilter","indexOf","compensateMultilineStringElementIndentation","formattedElement","offset","formatOneChildren","onlyPropsWithOriginalValue","haveDefaultValue","isInlineAttributeTooLong","attributes","inlineAttributeString","maxInlineAttributesLineLength","shouldRenderMultilineAttr","containsMultilineAttr","node","showDefaultProps","sortProps","out","outInlineAttr","outMultilineAttr","visibleAttributeNames","propFilter","defaultPropName","sortPropsByNames","formatProp","attributeName","newLvl","mergeSiblingPlainStringChildrenReducer","REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","isKeyedFragment","hasNoChildren","useFragmentShortSyntax","formatReactElementNode","jsxStopChars","shouldBeEscaped","some","jsxStopChar","preserveTrailingSpace","endsWith","startsWith","formatReactFragmentNode","TypeError","reactElementToJsxString","_ref$filterProps","_ref$showDefaultProps","_ref$showFunctions","_ref$tabStop","_ref$useBooleanShorth","_ref$useFragmentShort","_ref$sortProps","formatTree"],"sources":["/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/spacer.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/sortObject.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/tree.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/parser/parseReactElement.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatFunction.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatComplexDataStructure.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatPropValue.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatProp.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/mergeSiblingPlainStringChildrenReducer.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/sortPropsByNames.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/createPropFilter.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatReactElementNode.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatReactFragmentNode.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatTreeNode.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/formatter/formatTree.js","/Users/daniel/Documents/GitHub/miniproject/front/node_modules/react-element-to-jsx-string/src/index.js"],"sourcesContent":["/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n","/* @flow */\nimport * as React from 'react';\n\nfunction safeSortObject(value: any, seen: WeakSet<any>): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date, regexp and react element values as is\n  if (\n    value instanceof Date ||\n    value instanceof RegExp ||\n    React.isValidElement(value)\n  ) {\n    return value;\n  }\n\n  seen.add(value);\n\n  // make a copy of array with each item passed through the sorting algorithm\n  if (Array.isArray(value)) {\n    return value.map(v => safeSortObject(v, seen));\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      if (key === 'current' || seen.has(value[key])) {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = '[Circular]';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = safeSortObject(value[key], seen);\n      }\n      return result;\n    }, {});\n}\n\nexport default function sortObject(value: any): any {\n  return safeSortObject(value, new WeakSet());\n}\n","/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n","/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport {\n  ForwardRef,\n  isContextConsumer,\n  isContextProvider,\n  isForwardRef,\n  isLazy,\n  isMemo,\n  isProfiler,\n  isStrictMode,\n  isSuspense,\n  Memo,\n} from 'react-is';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getFunctionTypeName = (functionType): string => {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\n\nconst getWrappedComponentDisplayName = (Component: *): string => {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n};\n\n// heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\nconst getReactElementDisplayName = (element: ReactElement<*>): string => {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case isForwardRef(element):\n    case isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case isContextConsumer(element):\n      return `${element.type._context.displayName || 'Context'}.Consumer`;\n    case isContextProvider(element):\n      return `${element.type._context.displayName || 'Context'}.Provider`;\n    case isLazy(element):\n      return 'Lazy';\n    case isProfiler(element):\n      return 'Profiler';\n    case isStrictMode(element):\n      return 'StrictMode';\n    case isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n","import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport const inlineFunction = (fn: any): string =>\n  fn\n    .toString()\n    .split('\\n')\n    .map(line => line.trim())\n    .join('');\n\nexport const preserveFunctionLineBreak = (fn: any): string => fn.toString();\n\nconst defaultFunctionValue = inlineFunction;\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n","/* @flow */\n\nimport { isValidElement } from 'react';\nimport { prettyPrint } from '@base2/pretty-print-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = prettyPrint(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n","/* @flow */\n\nimport { isPlainObject } from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return `{new Date(NaN)}`;\n    }\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n","/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n","/* @flow */\n\nconst isKeyOrRefProps = (propName: string) => ['key', 'ref'].includes(propName);\n\nexport default (shouldSortUserProps: boolean) => (\n  props: string[]\n): string[] => {\n  const haveKeyProp = props.includes('key');\n  const haveRefProp = props.includes('ref');\n\n  const userPropsOnly = props.filter(oneProp => !isKeyOrRefProps(oneProp));\n\n  const sortedProps = shouldSortUserProps\n    ? [...userPropsOnly.sort()] // We use basic lexical order\n    : [...userPropsOnly];\n\n  if (haveRefProp) {\n    sortedProps.unshift('ref');\n  }\n\n  if (haveKeyProp) {\n    sortedProps.unshift('key');\n  }\n\n  return sortedProps;\n};\n","/* @flow */\n\nexport default function createPropFilter(\n  props: {},\n  filter: string[] | ((any, string) => boolean)\n) {\n  if (Array.isArray(filter)) {\n    return (key: string) => filter.indexOf(key) === -1;\n  } else {\n    return (key: string) => filter(props[key], key);\n  }\n}\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport sortPropsByNames from './sortPropsByNames';\nimport createPropFilter from './createPropFilter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  const propFilter = createPropFilter(props, filterProps);\n\n  Object.keys(props)\n    .filter(propFilter)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(propFilter)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n","/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${type}`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n","/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n","/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n","/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n\nexport {\n  inlineFunction,\n  preserveFunctionLineBreak,\n} from './formatter/formatFunction';\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}